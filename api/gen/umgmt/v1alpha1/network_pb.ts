// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file umgmt/v1alpha1/network.proto (package umgmt.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { FieldMask, Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum umgmt.v1alpha1.AddressType
 */
export enum AddressType {
  /**
   * @generated from enum value: ADDRESS_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ADDRESS_TYPE_IPV4 = 1;
   */
  IPV4 = 1,

  /**
   * @generated from enum value: ADDRESS_TYPE_IPV6 = 2;
   */
  IPV6 = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AddressType)
proto3.util.setEnumType(AddressType, "umgmt.v1alpha1.AddressType", [
  { no: 0, name: "ADDRESS_TYPE_UNSPECIFIED" },
  { no: 1, name: "ADDRESS_TYPE_IPV4" },
  { no: 2, name: "ADDRESS_TYPE_IPV6" },
]);

/**
 * @generated from enum umgmt.v1alpha1.AddressOrigin
 */
export enum AddressOrigin {
  /**
   * @generated from enum value: ADDRESS_ORIGIN_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ADDRESS_ORIGIN_STATIC = 1;
   */
  STATIC = 1,

  /**
   * @generated from enum value: ADDRESS_ORIGIN_DHCP = 2;
   */
  DHCP = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AddressOrigin)
proto3.util.setEnumType(AddressOrigin, "umgmt.v1alpha1.AddressOrigin", [
  { no: 0, name: "ADDRESS_ORIGIN_UNSPECIFIED" },
  { no: 1, name: "ADDRESS_ORIGIN_STATIC" },
  { no: 2, name: "ADDRESS_ORIGIN_DHCP" },
]);

/**
 * @generated from enum umgmt.v1alpha1.InterfaceType
 */
export enum InterfaceType {
  /**
   * @generated from enum value: INTERFACE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: INTERFACE_TYPE_ETHERNET = 1;
   */
  ETHERNET = 1,

  /**
   * @generated from enum value: INTERFACE_TYPE_WIFI = 2;
   */
  WIFI = 2,

  /**
   * @generated from enum value: INTERFACE_TYPE_CELLULAR = 3;
   */
  CELLULAR = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(InterfaceType)
proto3.util.setEnumType(InterfaceType, "umgmt.v1alpha1.InterfaceType", [
  { no: 0, name: "INTERFACE_TYPE_UNSPECIFIED" },
  { no: 1, name: "INTERFACE_TYPE_ETHERNET" },
  { no: 2, name: "INTERFACE_TYPE_WIFI" },
  { no: 3, name: "INTERFACE_TYPE_CELLULAR" },
]);

/**
 * @generated from enum umgmt.v1alpha1.Duplexing
 */
export enum Duplexing {
  /**
   * @generated from enum value: DUPLEXING_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: DUPLEXING_SIMPLEX = 1;
   */
  SIMPLEX = 1,

  /**
   * @generated from enum value: DUPLEXING_DUAL_SIMPLEX = 2;
   */
  DUAL_SIMPLEX = 2,

  /**
   * @generated from enum value: DUPLEXING_HALF_DUPLEX = 3;
   */
  HALF_DUPLEX = 3,

  /**
   * @generated from enum value: DUPLEXING_FULL_DUPLEX = 4;
   */
  FULL_DUPLEX = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Duplexing)
proto3.util.setEnumType(Duplexing, "umgmt.v1alpha1.Duplexing", [
  { no: 0, name: "DUPLEXING_UNSPECIFIED" },
  { no: 1, name: "DUPLEXING_SIMPLEX" },
  { no: 2, name: "DUPLEXING_DUAL_SIMPLEX" },
  { no: 3, name: "DUPLEXING_HALF_DUPLEX" },
  { no: 4, name: "DUPLEXING_FULL_DUPLEX" },
]);

/**
 * @generated from enum umgmt.v1alpha1.DnsType
 */
export enum DnsType {
  /**
   * @generated from enum value: DNS_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: DNS_TYPE_CLASSIC = 1;
   */
  CLASSIC = 1,

  /**
   * @generated from enum value: DNS_TYPE_DOT = 2;
   */
  DOT = 2,

  /**
   * @generated from enum value: DNS_TYPE_DOH = 3;
   */
  DOH = 3,

  /**
   * @generated from enum value: DNS_TYPE_DOQ = 4;
   */
  DOQ = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(DnsType)
proto3.util.setEnumType(DnsType, "umgmt.v1alpha1.DnsType", [
  { no: 0, name: "DNS_TYPE_UNSPECIFIED" },
  { no: 1, name: "DNS_TYPE_CLASSIC" },
  { no: 2, name: "DNS_TYPE_DOT" },
  { no: 3, name: "DNS_TYPE_DOH" },
  { no: 4, name: "DNS_TYPE_DOQ" },
]);

/**
 * @generated from enum umgmt.v1alpha1.TimeType
 */
export enum TimeType {
  /**
   * @generated from enum value: TIME_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TIME_TYPE_NTP = 1;
   */
  NTP = 1,

  /**
   * @generated from enum value: TIME_TYPE_NTS = 2;
   */
  NTS = 2,

  /**
   * @generated from enum value: TIME_TYPE_PTP = 3;
   */
  PTP = 3,

  /**
   * @generated from enum value: TIME_TYPE_ROUGHTIME = 4;
   */
  ROUGHTIME = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(TimeType)
proto3.util.setEnumType(TimeType, "umgmt.v1alpha1.TimeType", [
  { no: 0, name: "TIME_TYPE_UNSPECIFIED" },
  { no: 1, name: "TIME_TYPE_NTP" },
  { no: 2, name: "TIME_TYPE_NTS" },
  { no: 3, name: "TIME_TYPE_PTP" },
  { no: 4, name: "TIME_TYPE_ROUGHTIME" },
]);

/**
 * @generated from message umgmt.v1alpha1.Address
 */
export class Address extends Message<Address> {
  /**
   * @generated from field: umgmt.v1alpha1.AddressType type = 1;
   */
  type = AddressType.UNSPECIFIED;

  /**
   * @generated from field: string address = 2;
   */
  address = "";

  /**
   * @generated from field: string netmask = 3;
   */
  netmask = "";

  /**
   * @generated from field: umgmt.v1alpha1.AddressOrigin origin = 4;
   */
  origin = AddressOrigin.UNSPECIFIED;

  /**
   * @generated from field: string gateway = 5;
   */
  gateway = "";

  constructor(data?: PartialMessage<Address>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "umgmt.v1alpha1.Address";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(AddressType) },
    { no: 2, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "netmask", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "origin", kind: "enum", T: proto3.getEnumType(AddressOrigin) },
    { no: 5, name: "gateway", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Address {
    return new Address().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Address {
    return new Address().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Address {
    return new Address().fromJsonString(jsonString, options);
  }

  static equals(a: Address | PlainMessage<Address> | undefined, b: Address | PlainMessage<Address> | undefined): boolean {
    return proto3.util.equals(Address, a, b);
  }
}

/**
 * @generated from message umgmt.v1alpha1.Vlan
 */
export class Vlan extends Message<Vlan> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * @generated from field: uint32 id = 2;
   */
  id = 0;

  constructor(data?: PartialMessage<Vlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "umgmt.v1alpha1.Vlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vlan {
    return new Vlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vlan {
    return new Vlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vlan {
    return new Vlan().fromJsonString(jsonString, options);
  }

  static equals(a: Vlan | PlainMessage<Vlan> | undefined, b: Vlan | PlainMessage<Vlan> | undefined): boolean {
    return proto3.util.equals(Vlan, a, b);
  }
}

/**
 * @generated from message umgmt.v1alpha1.Interface
 */
export class Interface extends Message<Interface> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: umgmt.v1alpha1.InterfaceType type = 2;
   */
  type = InterfaceType.UNSPECIFIED;

  /**
   * @generated from field: string mac_address = 3;
   */
  macAddress = "";

  /**
   * @generated from field: repeated umgmt.v1alpha1.Address addresses = 4;
   */
  addresses: Address[] = [];

  /**
   * @generated from field: umgmt.v1alpha1.Vlan vlan = 5;
   */
  vlan?: Vlan;

  /**
   * @generated from field: uint32 mtu = 6;
   */
  mtu = 0;

  /**
   * @generated from field: uint32 speed_mbps = 7;
   */
  speedMbps = 0;

  /**
   * @generated from field: umgmt.v1alpha1.Duplexing duplexing = 8;
   */
  duplexing = Duplexing.UNSPECIFIED;

  /**
   * @generated from field: bool active = 9;
   */
  active = false;

  constructor(data?: PartialMessage<Interface>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "umgmt.v1alpha1.Interface";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(InterfaceType) },
    { no: 3, name: "mac_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "addresses", kind: "message", T: Address, repeated: true },
    { no: 5, name: "vlan", kind: "message", T: Vlan },
    { no: 6, name: "mtu", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "speed_mbps", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "duplexing", kind: "enum", T: proto3.getEnumType(Duplexing) },
    { no: 9, name: "active", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Interface {
    return new Interface().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Interface {
    return new Interface().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Interface {
    return new Interface().fromJsonString(jsonString, options);
  }

  static equals(a: Interface | PlainMessage<Interface> | undefined, b: Interface | PlainMessage<Interface> | undefined): boolean {
    return proto3.util.equals(Interface, a, b);
  }
}

/**
 * @generated from message umgmt.v1alpha1.DnsServer
 */
export class DnsServer extends Message<DnsServer> {
  /**
   * @generated from field: string fqdn = 1;
   */
  fqdn = "";

  /**
   * @generated from field: repeated umgmt.v1alpha1.Address address = 2;
   */
  address: Address[] = [];

  /**
   * @generated from field: umgmt.v1alpha1.DnsType type = 3;
   */
  type = DnsType.UNSPECIFIED;

  /**
   * @generated from field: bool dnssec = 4;
   */
  dnssec = false;

  constructor(data?: PartialMessage<DnsServer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "umgmt.v1alpha1.DnsServer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fqdn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "address", kind: "message", T: Address, repeated: true },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(DnsType) },
    { no: 4, name: "dnssec", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsServer {
    return new DnsServer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsServer {
    return new DnsServer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsServer {
    return new DnsServer().fromJsonString(jsonString, options);
  }

  static equals(a: DnsServer | PlainMessage<DnsServer> | undefined, b: DnsServer | PlainMessage<DnsServer> | undefined): boolean {
    return proto3.util.equals(DnsServer, a, b);
  }
}

/**
 * @generated from message umgmt.v1alpha1.TimeServer
 */
export class TimeServer extends Message<TimeServer> {
  /**
   * @generated from field: string fqdn = 1;
   */
  fqdn = "";

  /**
   * @generated from field: repeated umgmt.v1alpha1.Address address = 2;
   */
  address: Address[] = [];

  /**
   * @generated from field: umgmt.v1alpha1.TimeType type = 3;
   */
  type = TimeType.UNSPECIFIED;

  constructor(data?: PartialMessage<TimeServer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "umgmt.v1alpha1.TimeServer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fqdn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "address", kind: "message", T: Address, repeated: true },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(TimeType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeServer {
    return new TimeServer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeServer {
    return new TimeServer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeServer {
    return new TimeServer().fromJsonString(jsonString, options);
  }

  static equals(a: TimeServer | PlainMessage<TimeServer> | undefined, b: TimeServer | PlainMessage<TimeServer> | undefined): boolean {
    return proto3.util.equals(TimeServer, a, b);
  }
}

/**
 * @generated from message umgmt.v1alpha1.Network
 */
export class Network extends Message<Network> {
  /**
   * @generated from field: string hostname = 1;
   */
  hostname = "";

  /**
   * @generated from field: repeated umgmt.v1alpha1.Interface interfaces = 2;
   */
  interfaces: Interface[] = [];

  /**
   * @generated from field: repeated umgmt.v1alpha1.DnsServer dns_servers = 3;
   */
  dnsServers: DnsServer[] = [];

  /**
   * @generated from field: repeated umgmt.v1alpha1.TimeServer time_servers = 4;
   */
  timeServers: TimeServer[] = [];

  constructor(data?: PartialMessage<Network>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "umgmt.v1alpha1.Network";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "interfaces", kind: "message", T: Interface, repeated: true },
    { no: 3, name: "dns_servers", kind: "message", T: DnsServer, repeated: true },
    { no: 4, name: "time_servers", kind: "message", T: TimeServer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Network {
    return new Network().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJsonString(jsonString, options);
  }

  static equals(a: Network | PlainMessage<Network> | undefined, b: Network | PlainMessage<Network> | undefined): boolean {
    return proto3.util.equals(Network, a, b);
  }
}

/**
 * @generated from message umgmt.v1alpha1.GetNetworkInfoRequest
 */
export class GetNetworkInfoRequest extends Message<GetNetworkInfoRequest> {
  /**
   * @generated from field: google.protobuf.FieldMask field_mask = 1;
   */
  fieldMask?: FieldMask;

  constructor(data?: PartialMessage<GetNetworkInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "umgmt.v1alpha1.GetNetworkInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkInfoRequest {
    return new GetNetworkInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkInfoRequest {
    return new GetNetworkInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkInfoRequest {
    return new GetNetworkInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetNetworkInfoRequest | PlainMessage<GetNetworkInfoRequest> | undefined, b: GetNetworkInfoRequest | PlainMessage<GetNetworkInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetNetworkInfoRequest, a, b);
  }
}

/**
 * @generated from message umgmt.v1alpha1.GetNetworkInfoResponse
 */
export class GetNetworkInfoResponse extends Message<GetNetworkInfoResponse> {
  /**
   * @generated from field: repeated umgmt.v1alpha1.Network network = 1;
   */
  network: Network[] = [];

  constructor(data?: PartialMessage<GetNetworkInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "umgmt.v1alpha1.GetNetworkInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "network", kind: "message", T: Network, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkInfoResponse {
    return new GetNetworkInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkInfoResponse {
    return new GetNetworkInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkInfoResponse {
    return new GetNetworkInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetNetworkInfoResponse | PlainMessage<GetNetworkInfoResponse> | undefined, b: GetNetworkInfoResponse | PlainMessage<GetNetworkInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetNetworkInfoResponse, a, b);
  }
}

